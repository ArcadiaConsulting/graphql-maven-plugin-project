package ${package};
#macro(inputParams)#foreach ($inputParameter in $field.inputParameters)${inputParameter.type.classSimpleName} ${inputParameter.name}#if($foreach.hasNext), #end#end#end

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * @author generated by graphql-maven-plugin
 * @See https://github.com/graphql-java-generator/graphql-java-generator
 */
public abstract class ${object.name} {

	/** Logger for this class */
	private static Logger logger = LogManager.getLogger();

#foreach ($field in $object.fields)
	/**
	 * This method is expected by the graphql-java framework. It will be called when this ${type} is called. It offers a logging of the call (if in debug mode), 
	 * or of the call and its parameters (if in trace mode).
	 */
	public ${field.type.classSimpleName} ${field.name}(#inputParams()) {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of $type '${field.name}' with parameters: #foreach ($inputParameter in $field.inputParameters){}#if($foreach.hasNext),#end #end"#foreach ($inputParameter in $field.inputParameters), ${inputParameter.name}#end);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of $type '${field.name}'");
		}
		
		return do${field.pascalCaseName}(#foreach ($inputParameter in $field.inputParameters)${inputParameter.name}#if($foreach.hasNext), #end#end);
	}

	/**
	 * This method is called when this ${type} is called. The implementation code of the server part should create a class extending this ${type}
	 * {@link ${object.name}), and implement the actual ${type}.
	 */
	abstract protected ${field.type.classSimpleName} do${field.pascalCaseName}(#foreach ($inputParameter in $field.inputParameters)${inputParameter.type.classSimpleName} ${inputParameter.name}#if($foreach.hasNext), #end#end);
	
#end
}
