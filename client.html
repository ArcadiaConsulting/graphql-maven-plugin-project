<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from src\site\markdown/client.md.vm at 2019-11-16 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GraphQL Java Generator - Maven Plugin &#x2013; GraphQL Maven Plugin (client mode)</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">
com.graphql-java-generator:graphql-maven-plugin-project
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xright"><a href="../graphql-maven-plugin-project" title="Project on Github">Project on Github</a>        &nbsp;| <span id="publishDate">Last Published: 2019-11-16</span>
        &nbsp;| <span id="projectVersion">Version: 1.0.0-RC2</span>
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Maven Plugin Usage</h5>
    <ul>
     <li class="none"><a href="index.html" title="Introduction">Introduction</a></li>
     <li class="none"><strong>Create a GraphQL Client</strong></li>
     <li class="none"><a href="server.html" title="Create a GraphQL Server">Create a GraphQL Server</a></li>
     <li class="none"><a href="schema_personalization.html" title="Howto personalize the generated code">Howto personalize the generated code</a></li>
    </ul>
       <h5>Internal stuff</h5>
    <ul>
     <li class="none"><a href="howto_publish_site.html" title="How to publish the site">How to publish the site</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="graphql-java-runtime/index.html" title="graphql-java-runtime">graphql-java-runtime</a></li>
     <li class="none"><a href="graphql-maven-plugin/index.html" title="Graphql Java Maven Plugin">Graphql Java Maven Plugin</a></li>
     <li class="none"><a href="graphql-maven-plugin-samples/index.html" title="graphql-maven-plugin-samples">graphql-maven-plugin-samples</a></li>
     <li class="none"><a href="graphql-java-client-dependencies/index.html" title="graphql-java-client-dependencies">graphql-java-client-dependencies</a></li>
     <li class="none"><a href="graphql-java-server-dependencies/index.html" title="graphql-java-server-dependencies">graphql-java-server-dependencies</a></li>
     <li class="none"><a href="graphql-maven-plugin-logic/index.html" title="graphql-maven-plugin-logic">graphql-maven-plugin-logic</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="https://maven.apache.org/" title="Maven" class="poweredBy">
        <img class="poweredBy"  alt="Maven" src="https://maven.apache.org/images/logos/maven-feather.png"     />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>GraphQL Maven Plugin (client mode)</h1>
<p>When configuring the graphql-maven-plugin in client mode, it reads a graphqls schema file, and will generates all the necessary code to make it easy to call a GraphQL server.</p>
<p>As an overview, it generates:</p>
<ul>

<li>One java class for the Query object</li>
<li>One java class for the Mutation object (if any)</li>
<li>One POJO for each standard object of the GraphQL object</li>
</ul>
<p>The generated code is stand-alone. That is: your project, when it runs, it doesn&#x2019;t depend on any dependency from graphql-java-generator.</p>
<p>This is why we call it an accelerator: you can generate the code once, and get rid of graphql-java-generator if you wish.</p>
<p>BTW: we think its better to continue using it! But you&#x2019;re free to leave, and keep the generated code.<br />
:)</p>
<p>First, you&#x2019;ll have to create or get your GraphQL schema. The GraphQL plugin expects a <i>.graphqls</i> file. See the <a class="externalLink" href="https://graphql.org/learn/schema/">GraphQL schema doc</a> for all the details.</p>
<p>Then, add the plugin to your Maven POM file:</p>

<div>
<div>
<pre class="source">&lt;project ...&gt;
...

	&lt;build&gt;
		&lt;plugins&gt;
...
			&lt;plugin&gt;
				&lt;groupId&gt;com.graphql-java-generator&lt;/groupId&gt;
				&lt;artifactId&gt;graphql-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;1.0.0-RC2&lt;/version&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;goals&gt;
							&lt;goal&gt;graphql&lt;/goal&gt;
						&lt;/goals&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
				&lt;configuration&gt;
					&lt;mode&gt;client&lt;/mode&gt;
					&lt;packageName&gt;my.target.package&lt;/packageName&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
...
		&lt;/plugins&gt;
	&lt;/build&gt;
...
&lt;/project&gt;
</pre></div></div>

<p>You must precise the mode. It can be either <i>client</i> or <i>server</i>.</p>
<p>You can define the package that will contain the generated code. If not defined, the default package is <i>com.generated.graphql</i>. This package contains the generated code.</p>
<p>The necessary runtime code source is joined to the generated code, but remains in its original package, which is <i>graphql.java.client.*</i> and <i>graphql.java.annotation</i>.</p>
<p>When in <i>client</i> mode, you can query the server with just one line of code.</p>
<p>For instance :</p>

<div>
<div>
<pre class="source">import my.target.package.Human; // my.target.package is package name defined in the pom
import my.target.package.QueryType; // my.target.package is package name defined in the pom

...

	QueryType queryType = new QueryType();
	Human human = queryType.human(&quot;{id name appearsIn homePlanet friends{name}}&quot;, &quot;180&quot;);
</pre></div></div>

<p>Where human is a POJO, that you can manipulate as any java object. This POJOs and the QueryType(s) have been generated at build time, thanks to the plugin configurated in the your pom.</p>
<p>A <i>good idea</i> is to prepare the queries at startup time. Doing this executes all the GraphQL query checks during the application startup. Preparing a query is actually <b>creating an create an ObjectResponse</b>. This ObjectResponse is then built once, and reused for each query execution of this type.</p>
<p>There are two ways to create an ObjectResponse (details below):</p>
<ul>

<li>The GraphQL way, with a string where you list the expected fields like this one &#x201c;{id name appearsIn homePlanet friends{name}}&#x201d; (more info <a class="externalLink" href="https://graphql.org/learn/queries/">https://graphql.org/learn/queries/</a>)
<ul>

<li>This is the shortest way.</li>
</ul>
</li>
<li>The java builder way, with a java call for each field (see below)
<ul>

<li>This is more verbose, especially when fetching subobjects. It&#x2019;s actually done under the hood, when you use the GraphQL way.</li>
</ul>
</li>
</ul>
<p>In both cases, the idea is to build an ObjectResponse once, that you&#x2019;ll reuse for every call of this type to the server. An ObjectResponse is actually the graphql-java-generator object created to match a query string like &#x201c;{id name appearsIn homePlanet friends{name}}&#x201d;.</p>
<p>This ObjectResponse is the heart of the graphql-java-generator, when in client mode. It is responsible for:</p>
<ul>

<li>Defining what fields are expected in the GraphQL server response, for instance &#x201c;{id name appearsIn homePlanet friends{name}}&#x201d;</li>
<li>Check the validity of the query string at build time. That is: if the query string is invalid, a GraphQLRequestPreparationException exception is thrown.</li>
<li>(in the near future) mark the queried fields as queried, so that calling a getter on a non-queried field result in an error (instead of &#x201c;believing&#x201d; that this value is null).</li>
</ul>
<p><i>Note: In all cases, an ObjectResponse is built. This will help to add future functionnalities</i>. For instance, in the near future, when you access a field, the generated code will check that this field has actually been queried.</p>
<p>To prepare the queries during startup, you can initialize a local variable, like in the given samples, for instance here is an extract of WithQueries, from the StarWars sample. In this sample, the <i>heroFriendsFriendsFriends()</i> method executes the query and returns the GraphQL server response, mapped into the relevant POJO.</p>

<div>
<div>
<pre class="source">public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder()
				.withQueryResponseDef(&quot;{id appearsIn friends {name friends {friends{id name appearsIn}}}}&quot;).build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
</pre></div></div>

<p>You can also use a Builder to generate the query, by adding field by field, and subobject by subobject, like below. Of course, it&#x2019;s more verbose.</p>

<div>
<div>
<pre class="source">public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		// Equivalent to  &quot;{id appearsIn name friends {name friends {friends{id name appearsIn}}} primaryFunction }&quot;
		ObjectResponse friends3 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;id&quot;).withField(&quot;name&quot;)
				.withField(&quot;appearsIn&quot;).build();
		ObjectResponse friends2 = ObjectResponse.newSubObjectBuilder(Character.class).withSubObject(&quot;friends&quot;, friends3)
				.build();
		ObjectResponse friends1 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;name&quot;)
				.withSubObject(&quot;friends&quot;, friends2).build();
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder().withField(&quot;id&quot;).withField(&quot;appearsIn&quot;)
				.withSubObject(&quot;friends&quot;, friends1).build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
</pre></div></div>

<p>Instead of create a local variable for your ObjectResponse, another idea is to create a Spring Bean:</p>

<div>
<div>
<pre class="source">	@Bean
	ObjectResponse heroResponse(QueryType queryType) {
		return queryType.getHeroResponseBuilder().build();
	}
</pre></div></div>

<p>Doing this allows you to use this ObjectResponse, later on, in other Spring component(s), with something like this:</p>

<div>
<div>
<pre class="source">	
	@Component
	class YourClass {
	
	@Resource
	ObjectResponse heroResponse;
	
	Character hero = queryType.hero(heroResponse, Episode.NEWHOPE);
</pre></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2019.All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
