<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from src\site\markdown/client.md.vm at 2019-12-09 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GraphQL Java Generator - Maven Plugin &#x2013; GraphQL Maven Plugin (client mode)</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">
com.graphql-java-generator:graphql-maven-plugin-project
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="projectVersion">Version: 1.1-SNAPSHOT</span>
      </div>
      <div class="xright"><a href="project.html" title="Project on Github">Project on Github</a>        &nbsp;| <span id="publishDate">Last Published: 2019-12-09</span>
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Maven Plugin Usage</h5>
    <ul>
     <li class="none"><a href="index.html" title="Introduction">Introduction</a></li>
     <li class="none"><strong>Create a GraphQL Client</strong></li>
     <li class="none"><a href="server.html" title="Create a GraphQL Server">Create a GraphQL Server</a></li>
     <li class="none"><a href="schema_personalization.html" title="Howto personalize the generated code">Howto personalize the generated code</a></li>
    </ul>
       <h5>Internal stuff</h5>
    <ul>
     <li class="none"><a href="howto_publish_site.html" title="How to publish the site">How to publish the site</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="graphql-java-runtime/index.html" title="graphql-java-runtime">graphql-java-runtime</a></li>
     <li class="none"><a href="graphql-maven-plugin/index.html" title="Graphql Java Maven Plugin">Graphql Java Maven Plugin</a></li>
     <li class="none"><a href="graphql-maven-plugin-samples/index.html" title="graphql-maven-plugin-samples">graphql-maven-plugin-samples</a></li>
     <li class="none"><a href="graphql-java-client-dependencies/index.html" title="graphql-java-client-dependencies">graphql-java-client-dependencies</a></li>
     <li class="none"><a href="graphql-java-server-dependencies/index.html" title="graphql-java-server-dependencies">graphql-java-server-dependencies</a></li>
     <li class="none"><a href="graphql-maven-plugin-logic/index.html" title="graphql-maven-plugin-logic">graphql-maven-plugin-logic</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="https://maven.apache.org/" title="Maven" class="poweredBy">
        <img class="poweredBy"  alt="Maven" src="https://maven.apache.org/images/logos/maven-feather.png"     />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>GraphQL Maven Plugin (client mode)</h1>
<p>When configuring the graphql-maven-plugin in client mode, it reads a graphqls schema file, and will generates all the necessary code to make it easy to call a GraphQL server.</p>
<p>As an overview, it generates:</p>
<ul>

<li>One java class for the Query object</li>
<li>One java class for the Mutation object (if any)</li>
<li>One POJO for each standard object of the GraphQL object</li>
<li>All the necessary runtime is actually attached as source code into your project: the generated code is stand-alone. So, your project, when it runs, doesn&#x2019;t depend on any external dependency from graphql-java-generator. This is why we call it an accelerator: you can generate the code once, and get rid of graphql-java-generator if you wish. BTW: we think its better to continue using it! But you&#x2019;re free to leave, and keep the generated code. :)</li>
</ul>
<p>First, you&#x2019;ll have to create or get your GraphQL schema. The GraphQL plugin expects a <i>.graphqls</i> file. See the <a class="externalLink" href="https://graphql.org/learn/schema/">GraphQL schema doc</a> for all the details.</p>
<p>Then, add the plugin to your Maven POM file:</p>

<div>
<div>
<pre class="source">&lt;project ...&gt;
...

	&lt;build&gt;
		&lt;plugins&gt;
...
			&lt;plugin&gt;
				&lt;groupId&gt;com.graphql-java-generator&lt;/groupId&gt;
				&lt;artifactId&gt;graphql-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;goals&gt;
							&lt;goal&gt;graphql&lt;/goal&gt;
						&lt;/goals&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
				&lt;configuration&gt;
					&lt;mode&gt;client&lt;/mode&gt;
					&lt;packageName&gt;my.target.package&lt;/packageName&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
...
		&lt;/plugins&gt;
	&lt;/build&gt;
...
&lt;/project&gt;
</pre></div></div>

<p>The mode is optional, here, as client is the default one. Valid values are: <i>client</i> and <i>server</i>.</p>
<p>You can define the package that will contain the generated code. If you don&#x2019;t, the default package is <i>com.generated.graphql</i>. This package contains the generated code.</p>
<p>The necessary runtime code source is joined to the generated code, but remains in its original package, which is <i>graphql.java.client.*</i> and <i>graphql.java.annotation</i>. So everything is embedded.</p>
<p>When in <i>client</i> mode, you can query the server with just one line of code.</p>
<p>For instance :</p>

<div>
<div>
<pre class="source">import my.target.package.Human; // my.target.package is the package name defined in the pom
import my.target.package.QueryType; // my.target.package is the package name defined in the pom

...

	QueryType queryType = new QueryType();
	Human human = queryType.human(&quot;{id name appearsIn homePlanet friends{name}}&quot;, &quot;180&quot;);
</pre></div></div>

<p>Where human is a POJO, that you can manipulate as any java object. This POJOs and the QueryType(s) have been generated at build time, thanks to the plugin configured in your pom.</p>
<p>You call query and mutation in the same way: by calling the relevant java method that has been generated at build time.</p>
<p>The Query and the Mutation generated classes have the same name, as defined in the GraphQL schema. They are generated into the package defined in your pom (see above). They have two constructors:</p>
<ul>

<li><i>Xxx(String graphqlEndpoint)</i>: This constructor is for http GraphQL server. Just provide here the URL for the GraphQL endpoint, for instance &#x201c;<a class="externalLink" href="http://localhost:8180/graphql">http://localhost:8180/graphql</a>&#x201d;</li>
<li><i>Xxx(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)</i>: This constructor is for https GraphQL server. The parameters are :
<ul>

<li>The https URL for the GraphQL endpoint. For instance: &#x201c;<a class="externalLink" href="https://localhost:8443/starwars/graphql">https://localhost:8443/starwars/graphql</a>&#x201d;</li>
<li>The SSLContext. You must provide such a context. There are a lot of doc on the net, for instance <a class="externalLink" href="https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/class-use/SSLContext.html">use these initiators</a> or <a class="externalLink" href="https://www.codota.com/code/java/methods/javax.net.ssl.SSLContext/init">these samples</a></li>
<li>The hostnameVerifier. You can the same <a class="externalLink" href="https://forums.xamarin.com/discussion/14527/how-do-i-implement-a-custom-host-name-verifier">as here</a></li>
</ul>
</li>
</ul>
<p>Once the Query or/and the Mutation class(es) is/are created, you can call the GraphQL server. Just use the instance, you created, and call the query or mutation method.</p>
<p>Each such method has the same name as in the GraphQL schema. Each such method is generated twice, with two kind of parameters, described just below. It returns the type indicated in the GraphQL schema. The two kind of methods are the direct query (or mutation) and the prepared query (or mutation).</p>
<p>The signature is of this type:</p>

<div>
<div>
<pre class="source">    Yyyy xxx(String queryResponseDef, Pppp param1, Pppp param2..)
</pre></div></div>

<p>Where: * Yyyy is the type, defined in the GraphQL schema as the return type for this Query or Mutation. Yyyy is actually the POJO generated by graphql-java-generator, from the GraphQL Type of the same name. * xxx is the name of the Query or Mutation * queryResponseDef is directly the GraphQL request * param1, param2 (..) are the parameters, as defined in the GraphQL schema</p>
<p>Here is a sample, taken from the StarWars sample project:</p>

<div>
<div>
<pre class="source">    mutationType.addFriend(&quot;{id name appearsIn friends {id name}}&quot;, idCharacter, idNewFriend);
</pre></div></div>

<p>This is the simplest way to execute a GraphQL query. But:</p>
<ul>

<li>There are some checks at each execution (to check that your parameters are valid). It is more efficient to prepare the request first (see below).</li>
<li>And you&#x2019;ll know if the request is valid only when you execute it</li>
</ul>
<p>In this second method call, you have to prepare the response of the query/mutation first. The idea is to build an <i>ObjectResponse</i> once, that you&#x2019;ll reuse for every call of this type to the server. An <i>ObjectResponse</i> is actually the graphql-java-generator object created to match a query string like &#x201c;{id name appearsIn homePlanet friends{name}}&#x201d;.</p>
<p>You do this once, typically when the application starts:</p>
<ul>

<li>The graphql-java-generator initializes its stuff only once</li>
<li>You known at startup time that all your requests are valid.
<ul>

<li>Also, when starting an integration test, the requests are prepared &#x2026; and checked.</li>
</ul>
</li>
</ul>
<p>There are two ways to prepare the query/mutation response:</p>
<ul>

<li>The builder way:</li>
</ul>

<div>
<div>
<pre class="source">ObjectResponse addFriendResponse = mutationType.getAddFriendResponseBuilder().withField(&quot;id&quot;).withField(&quot;name&quot;).withField(&quot;appearsIn&quot;)
				.withSubObject(&quot;friends&quot;, ObjectResponse.newSubObjectBuilder(Character.class).build()).build();
</pre></div></div>

<ul>

<li>The GraphQL way:</li>
</ul>

<div>
<div>
<pre class="source">ObjectResponse addFriendResponse = mutationType.getAddFriendResponseBuilder().withQueryResponseDef(&quot;{id name appearsIn friends {id name}}&quot;).build();
</pre></div></div>

<p>Then, you can call to the method itself:</p>

<div>
<div>
<pre class="source">    mutationType.addFriend(addFriendResponse, idCharacter, idNewFriend);
</pre></div></div>

<p>The <i>ObjectResponse</i> is the heart of the graphql-java-generator, when in client mode. It is responsible for:</p>
<ul>

<li>Defining what fields are expected in the GraphQL server response, for instance &#x201c;{id name appearsIn homePlanet friends{name}}&#x201d;</li>
<li>Check the validity of the query string at build time. That is: if the query string is invalid, a GraphQLRequestPreparationException exception is thrown.</li>
<li>(in the near future) mark the queried fields as queried, so that calling a getter on a non-queried field result in an error (instead of &#x201c;believing&#x201d; that this value is null).</li>
</ul>
<p>To prepare the queries during startup, you can initialize a local variable, like in the given samples, for instance here is an extract of WithQueries, from the StarWars sample. In this sample, the <i>heroFriendsFriendsFriends()</i> method executes the query and returns the GraphQL server response, mapped into the relevant POJO.</p>

<div>
<div>
<pre class="source">public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder()
				.withQueryResponseDef(&quot;{id appearsIn friends {name friends {friends{id name appearsIn}}}}&quot;).build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
</pre></div></div>

<p>You can also use a Builder to generate the query, by adding field by field, and subobject by subobject, like below. Of course, it&#x2019;s more verbose.</p>

<div>
<div>
<pre class="source">public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		// Equivalent to  &quot;{id appearsIn name friends {name friends {friends{id name appearsIn}}} primaryFunction }&quot;
		ObjectResponse friends3 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;id&quot;).withField(&quot;name&quot;)
				.withField(&quot;appearsIn&quot;).build();
		ObjectResponse friends2 = ObjectResponse.newSubObjectBuilder(Character.class).withSubObject(&quot;friends&quot;, friends3)
				.build();
		ObjectResponse friends1 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;name&quot;)
				.withSubObject(&quot;friends&quot;, friends2).build();
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder().withField(&quot;id&quot;).withField(&quot;appearsIn&quot;)
				.withSubObject(&quot;friends&quot;, friends1).build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
</pre></div></div>

<p>Instead of create a local variable for your ObjectResponse, another idea is to create a Spring Bean:</p>

<div>
<div>
<pre class="source">	@Bean
	ObjectResponse heroResponse(QueryType queryType) {
		return queryType.getHeroResponseBuilder().build();
	}
</pre></div></div>

<p>Doing this allows you to use this ObjectResponse, later on, in other Spring component(s), with something like this:</p>

<div>
<div>
<pre class="source">	
	@Component
	class YourClass {
	
	@Resource
	ObjectResponse heroResponse;
	
	Character hero = queryType.hero(heroResponse, Episode.NEWHOPE);
</pre></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2019.All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
