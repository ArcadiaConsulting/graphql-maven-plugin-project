/**
 * 
 */
package com.graphql_java_generator.client.request;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;

/**
 * This class contains the description for a GraphQL request that will be sent to the server. It's an abstract class,
 * and can not be use directly: a concrete class is generated by the plugin, when in client mode. This concrete class
 * provides all the necessary context to this abstract class for it to work properly.<BR/>
 * This class stores:
 * <UL>
 * <LI>The query part, if any</LI>
 * <LI>The mutation part, if any</LI>
 * <LI>The subscription part, if any</LI>
 * <LI>The fragments, if any</LI>
 * </UL>
 * 
 * @author etienne-sf
 */
public abstract class AbstractGraphQLRequest {

	/**
	 * The list of character that can separate tokens, in the GraphQL query string. These token are read by the
	 * {@link StringTokenizer}.
	 */
	public static final String STRING_TOKENIZER_DELIMITER = " {},:()\n\r\t@";

	/** The generated class that is based on the standard GraphQL introspection query */
	Class<?> introspectionQueryTypeClass = null;

	/** The query, if any */
	QueryField query = null;

	/** The mutation, if any */
	QueryField mutation = null;

	/** The mutation, if any */
	QueryField subscription = null;

	/** All the fragments defined for this query */
	List<Fragment> fragments = new ArrayList<>();

	/**
	 * Null if the request is a full request. Mandatory if the request is a partial request. When this GraphQLRequest is
	 * built for a partial query, that is for a particular query/mutation/subscription, then fieldName states whether
	 * this queryName is actually a query, a mutation or a subscription.
	 */
	final RequestType requestType;
	/**
	 * Null if the request is a full request. Mandatory if the request is a partial request.<BR/>
	 * When this GraphQLRequest is built for a partial query, that is for a particular query/mutation/subscription, then
	 * queryName is the name of the query, mutation or subscription. This allow to check that the GraphQLRequest is the
	 * good to be executed for this partial query.
	 */
	final String queryName;

	/**
	 * Create the instance, from the GraphQL request, for a partial request.
	 * 
	 * @param graphQLRequest
	 *            The <B>partial</B> GraphQL request, in text format. Writing partial request allows use to execute a
	 *            query/mutation/subscription, and only define what's expected as a response for this
	 *            query/mutation/subscription. You can send the parameters for this query/mutation/subscription as
	 *            parameter of the java method, without dealing with bind variable in the GraphQL query. Please read the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">client doc
	 *            page</A> for more information, including hints and limitations.
	 * @param requestType
	 *            The information whether this queryName is actually a query, a mutation or a subscription
	 * @param queryName
	 *            The name of the query, mutation or subscription
	 * @throws GraphQLRequestPreparationException
	 */
	public AbstractGraphQLRequest(String graphQLRequest, RequestType requestType, String queryName)
			throws GraphQLRequestPreparationException {
		if (requestType == null) {
			throw new NullPointerException("requestType is mandatory, but a null value has been provided");
		}
		if (queryName == null) {
			throw new NullPointerException("queryName is mandatory, but a null value has been provided");
		}
		this.requestType = requestType;
		this.queryName = queryName;
		readGraphQLRequest(graphQLRequest);
	}

	/**
	 * Create the instance, from the GraphQL request, for a full request.
	 * 
	 * @param graphQLRequest
	 *            The GraphQL request, in text format, as defined in the GraphQL specifications, and as it can be used
	 *            in GraphiQL. Please read the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">client doc
	 *            page</A> for more information, including hints and limitations.
	 * 
	 * @throws GraphQLRequestPreparationException
	 */
	public AbstractGraphQLRequest(String graphQLRequest) throws GraphQLRequestPreparationException {
		this.requestType = null;
		this.queryName = null;
		readGraphQLRequest(graphQLRequest);
	}

	/**
	 * Reads the GraphQL request, and generates all the internal structure. It will:
	 * <UL>
	 * <LI>Read the query and/or the mutation</LI>
	 * <LI>Read all fragment definitions</LI>
	 * <LI>For all non scalar field, subfields (and so on recursively), if they are empty (that is the query doesn't
	 * define the requested fields of a non scalar field, then all its scalar fields are added)</LI>
	 * <LI>Add the introspection __typename field to all scalar field list, if it doesnt't already exist. This is
	 * necessary to allow proper deserialization of interfaces and unions.</LI>
	 * </UL>
	 * 
	 * @param graphQLRequest
	 * @throws GraphQLRequestPreparationException
	 */
	private void readGraphQLRequest(String graphQLRequest) throws GraphQLRequestPreparationException {

		// Ok, we have to parse a string which looks like that: "query {human(id: &humanId) { id name friends{name}}}"
		// We tokenize the string, by using the space as a delimiter, and all other special GraphQL characters
		StringTokenizer st = new StringTokenizer(graphQLRequest, STRING_TOKENIZER_DELIMITER, true);
		RequestType requestType = RequestType.query; // If not precised, then it's a query

		// We scan the input string. It may contain fragment definition and query/mutation/subscription
		while (st.hasMoreTokens()) {
			String token = st.nextToken();

			switch (token) {
			case " ":
			case "\n":
			case "\r":
			case "\t":
				break;
			case "fragment":
				fragments.add(new Fragment(st, null));
				break;
			case "query":
			case "mutation":
			case "subscription":
				requestType = RequestType.valueOf(token);
				break;
			case "{":
				// We read the query/mutation/subscription like any field.
				switch (requestType) {
				case query:
					query = getQueryContext();// Get the query field from the concrete class
					query.readTokenizerForResponseDefinition(st);
					break;
				case mutation:
					mutation = getMutationContext();// Get the mutation field from the concrete class
					mutation.readTokenizerForResponseDefinition(st);
					break;
				case subscription:
					subscription = getSubscriptionContext();// Get the subscription field from the concrete class
					subscription.readTokenizerForResponseDefinition(st);
					break;
				default:
					throw new GraphQLRequestPreparationException("Non managed request type '" + requestType
							+ " while reading the GraphQL request: " + graphQLRequest);
				}
				break;
			default:
				throw new GraphQLRequestPreparationException(
						"Unknown token '" + token + " while reading the GraphQL request: " + graphQLRequest);
			}
		}

		if (query == null && mutation == null) {
			throw new GraphQLRequestPreparationException("No response definition found");
		}

		// We need the __typename fields, to properly parse the JSON response for interfaces and unions.
		// So we add it for every returned object.
		if (query != null) {
			query.addTypenameFields();
		}
		if (mutation != null) {
			mutation.addTypenameFields();
		}
		if (subscription != null) {
			subscription.addTypenameFields();
		}
	}

	/**
	 * 
	 * @param params
	 * @return
	 * @throws GraphQLRequestExecutionException
	 */
	public String buildRequest(Map<String, Object> params) throws GraphQLRequestExecutionException {
		StringBuilder sb = new StringBuilder();

		// Let's start by the fragments
		for (Fragment fragment : fragments) {
			fragment.appendToGraphQLRequests(sb, params);
		}

		// Then the other parts of the request
		if (query != null) {
			query.appendToGraphQLRequests(sb, params);
		}
		if (mutation != null) {
			mutation.appendToGraphQLRequests(sb, params);
		}
		if (subscription != null) {
			subscription.appendToGraphQLRequests(sb, params);
		}

		return sb.toString();
	}

	/**
	 * Retrieved the {@link QueryField} for the query (that is the query type coming from the GraphQL schema) from the
	 * concrete class.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	protected abstract QueryField getQueryContext() throws GraphQLRequestPreparationException;

	/**
	 * Retrieved the {@link QueryField} for the mutation (that is the mutation type coming from the GraphQL schema) from
	 * the concrete class.
	 * 
	 * @return
	 */
	protected abstract QueryField getMutationContext() throws GraphQLRequestPreparationException;

	/**
	 * Retrieved the {@link QueryField} for the subscription (that is the subscription type coming from the GraphQL
	 * schema) from the concrete class.
	 * 
	 * @return
	 */
	protected abstract QueryField getSubscriptionContext() throws GraphQLRequestPreparationException;

	public static String getStringTokenizerDelimiter() {
		return STRING_TOKENIZER_DELIMITER;
	}

	public Class<?> getIntrospectionQueryTypeClass() {
		return introspectionQueryTypeClass;
	}

	public QueryField getQuery() {
		return query;
	}

	public QueryField getMutation() {
		return mutation;
	}

	public QueryField getSubscription() {
		return subscription;
	}

	public List<Fragment> getFragments() {
		return fragments;
	}

	public RequestType getRequestType() {
		return requestType;
	}

	public String getQueryName() {
		return queryName;
	}

}
