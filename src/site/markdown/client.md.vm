# GraphQL Maven Plugin (client mode)


## Presentation

When configuring the graphql-maven-plugin in client mode, it reads a graphqls schema file, and will generates all the necessary code to make it easy to call a GraphQL server. 

As an overview, it generates:

* One java class for the Query object
* One java class for the Mutation object (if any)
* One POJO for each standard object of the GraphQL object
* All the necessary runtime is actually attached as source code into your project: the generated code is stand-alone. So, your project, when it runs, doesn't depend on any external dependency from graphql-java-generator. This is why we call it an accelerator: you can generate the code once, and get rid of graphql-java-generator if you wish. BTW: we think its better to continue using it! But you're free to leave, and keep the generated code. :)


## How to use the plugin ?

First, you'll have to create or get your GraphQL schema. The GraphQL plugin expects a _.graphqls_ file. See the [GraphQL schema doc](https://graphql.org/learn/schema/) for all the details.

Then, add the plugin to your Maven POM file:

```XML
<project ...>
...

	<build>
		<plugins>
...
			<plugin>
				<groupId>com.graphql-java-generator</groupId>
				<artifactId>graphql-maven-plugin</artifactId>
				<version>${lastReleasedVersion}</version>
				<executions>
					<execution>
						<goals>
							<goal>graphql</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<mode>client</mode>
					<packageName>my.target.package</packageName>
				</configuration>
			</plugin>
...
		</plugins>
	</build>
...
</project>
```

The mode is optional, here, as client is the default one. Valid values are: _client_ and _server_.

You can define the package that will contain the generated code. If you don't, the default package is _com.generated.graphql_. This package contains the generated code. 

The necessary runtime code source is joined to the generated code, but remains in its original package, which is _graphql.java.client.*_ and _graphql.java.annotation_. So everything is embedded.

## How to execute a GraphQL query ?

When in _client_ mode, you can query the server with just one line of code.

For instance :

```Java
import my.target.package.Human; // my.target.package is the package name defined in the pom
import my.target.package.QueryType; // my.target.package is the package name defined in the pom

...

	QueryType queryType = new QueryType();
	Human human = queryType.human("{id name appearsIn homePlanet friends{name}}", "180");
```

Where human is a POJO, that you can manipulate as any java object. This POJOs and the QueryType(s) have been generated at build time, thanks to the plugin configured in your pom.  

## GraphQL query (and mutation) calls

You call query and mutation in the same way: by calling the relevant java method that has been generated at build time.

The Query and the Mutation generated classes have the same name, as defined in the GraphQL schema. They are generated into the package defined in your pom (see above). The standard way is to provide the URL (either http or https) to the constuctor of the Query or Mutation class.

For https server, a second constructor allows you to provide a specific SSLContext and HostnameVerifier. We use it in Integration Test, to allow the client to connect to an https server with a self-signed certificate (as we don't have the money to buy a proper certificate)

Once the Query or/and the Mutation class(es) is/are created, you can call the GraphQL server. Just use the instance, you created, and call the query or mutation method.

Each such method has the same name as in the GraphQL schema. Each such method is generated twice, with two kind of parameters, described just below. It returns the type indicated in the GraphQL schema. The two kind of methods are the direct query (or mutation) and the prepared query (or mutation).

### Direct Query (or Mutation) call

The signature is of this type:

```Java
    Yyyy xxx(String queryResponseDef, Pppp param1, Pppp param2..)
```

Where:
* Yyyy is the type, defined in the GraphQL schema as the return type for this Query or Mutation. Yyyy is actually the POJO generated by graphql-java-generator, from the GraphQL Type of the same name.
* xxx is the name of the Query or Mutation
* queryResponseDef is directly the GraphQL request 
* param1, param2 (..) are the parameters, as defined in the GraphQL schema

Here is a sample, taken from the StarWars sample project:

```Java
    mutationType.addFriend("{id name appearsIn friends {id name}}", idCharacter, idNewFriend);
```

This is the simplest way to execute a GraphQL query. But:

* There are some checks at each execution (to check that your parameters are valid). It is more efficient to prepare the request first (see below).
* And you'll know if the request is valid only when you execute it 

### Prepared Query (or Mutation) call

In this second method call, you have to prepare the response of the query/mutation first. The idea is to build an _ObjectResponse_ once, that you'll reuse for every call of this type to the server. An _ObjectResponse_ is actually the graphql-java-generator object created to match a query string like "{id name appearsIn homePlanet friends{name}}".

You do this once, typically when the application starts:

* The graphql-java-generator initializes its stuff only once
* You known at startup time that all your requests are valid.
    * Also, when starting an integration test, the requests are prepared ... and checked. 

There are two ways to prepare the query/mutation response:

* The builder way:

```Java
ObjectResponse addFriendResponse = mutationType.getAddFriendResponseBuilder().withField("id").withField("name").withField("appearsIn")
				.withSubObject("friends", ObjectResponse.newSubObjectBuilder(Character.class).build()).build();
```

* The GraphQL way:

```Java
ObjectResponse addFriendResponse = mutationType.getAddFriendResponseBuilder().withQueryResponseDef("{id name appearsIn friends {id name}}").build();
```

Then, you can call to the method itself:

```Java
    mutationType.addFriend(addFriendResponse, idCharacter, idNewFriend);
```

## Prepare your GraphQL queries

The _ObjectResponse_ is the heart of the graphql-java-generator, when in client mode. It is responsible for:

* Defining what fields are expected in the GraphQL server response, for instance "{id name appearsIn homePlanet friends{name}}" 
* Check the validity of the query string at build time. That is: if the query string is invalid, a GraphQLRequestPreparationException exception is thrown.
* (in the near future) mark the queried fields as queried, so that calling a getter on a non-queried field result in an error (instead of "believing" that this value is null). 

## Create an ObjectResponse with a query string

To prepare the queries during startup, you can initialize a local variable, like in the given samples, for instance here is an extract of WithQueries, from the StarWars sample. In this sample, the _heroFriendsFriendsFriends()_ method executes the query and returns the GraphQL server response, mapped into the relevant POJO.

```Java
public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder()
				.withQueryResponseDef("{id appearsIn friends {name friends {friends{id name appearsIn}}}}").build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
```

## Create an ObjectResponse with an ObjectResponse Builder

 You can also use a Builder to generate the query, by adding field by field, and subobject by subobject, like below. Of course, it's more verbose.

```Java
public class WithQueries implements Queries {

	final QueryType queryType;
	ObjectResponse heroFriendsFriendsFriendsResponse;
...

	public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
			throws GraphQLRequestPreparationException {
		queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
		// Equivalent to  "{id appearsIn name friends {name friends {friends{id name appearsIn}}} primaryFunction }"
		ObjectResponse friends3 = ObjectResponse.newSubObjectBuilder(Character.class).withField("id").withField("name")
				.withField("appearsIn").build();
		ObjectResponse friends2 = ObjectResponse.newSubObjectBuilder(Character.class).withSubObject("friends", friends3)
				.build();
		ObjectResponse friends1 = ObjectResponse.newSubObjectBuilder(Character.class).withField("name")
				.withSubObject("friends", friends2).build();
		heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder().withField("id").withField("appearsIn")
				.withSubObject("friends", friends1).build();
...
	}

	public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
		return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
	}

}
```


## Use a Spring Bean

Instead of create a local variable for your ObjectResponse, another idea is to create a Spring Bean:

```Java
	@Bean
	ObjectResponse heroResponse(QueryType queryType) {
		return queryType.getHeroResponseBuilder().build();
	}
```

Doing this allows you to use this ObjectResponse, later on, in other Spring component(s), with something like this: 

```Java
	
	@Component
	class YourClass {
	
	@Resource
	ObjectResponse heroResponse;
	
	Character hero = queryType.hero(heroResponse, Episode.NEWHOPE);
```